---
slug: "231109-1"
title: "작은 차이가 만드는 문제"
description: ""
summary: ""
date: 2023-11-09T00:00:00+09:00
lastmod: 2023-11-09T00:00:00+09:00
draft: false
weight: 50
images: []
categories: ["Dev - Business"]
tags: ["Elasticsearch", "Kubernetes", "Oracle"]
contributors: ["LHU"]
pinned: false
homepage: false
---

---

개발자도 사람이기 때문에 실수를 안 할 수는 없습니다. 그걸 또 해결하는 게 개발자의 일이기도 합니다. 문제는 한두 줄 고치거나 설정 몇 개 간단히 건드리면 끝날 정도로 간단한 작업 때문에, 때로는 큰 오류가 발생할 수도 있다는 점입니다. 이런 점들은 따로 정리를 해 두어야겠다는 생각이 들었습니다. 오히려 큰 문제였다면 인상이 강렬해서 기억이 잘 나는 경우가 많은데, 작은 문제는 그렇지 않을 수 있으니...

이 글에서는 작은 차이지만 큰 영향을 끼칠 수 있고, 일반적으로 통용되는 케이스를 3가지 정도 적어 두려고 합니다. 내용이 내용이니만큼 가볍고, 어찌 보면 **"이 정도는 당연한 거 아닌가?"** 하는 내용이 있을 수도 있겠습니다. 아이러니하게도 그러니까 더더욱 이런 글을 적는 거지만요.

<br>

#### 시간,날짜 맞추기

사실 날짜가 아니어도 단위나 형식을 통일하는 것은 중요하고 해두면 여러 모로 편하지만, 이 부문에서 시간을 넘어서는 건 찾기 힘든 것 같습니다. 지구가 둥글기 때문에 timezone에 따라 표시할 시간이 달라지고, 또 서양권, 동양권, 기타 규격마다 표시하는 방식이 다르기 때문입니다. 예를 들어 한국은 `2023년 11월 08일`인데 미국은 `11/08/2023` 이런 식입니다. 예시로 [IBM 홈페이지의 표][ref1]를 하나 가져왔는데, 정말 종류가 많습니다.  
이렇기 때문에 사용하고 있는 서버의 default timezone이라던가 language 설정에 따라 기본 시간 포맷이 모두 제각각입니다. 그리고 이런 설정을 기반으로 DB에서 포맷을 정하는 등, 미처 생각하지 못한 Side Effect가 발생할 가능성도 높습니다.

실제로 22년 프로젝트 중에 로컬 환경에서 잘 작동하던 코드가 배포 환경에서 Oracle DB 에러가 뜨면서 작동하지 않는 문제가 있었는데, 각 환경의 기본 설정 차이로 인해 `NLS_DATE_FORMAT` 변수가 서로 달라 시간 포맷이 맞지 않았고, 이로 인해 오류가 생기는 케이스였습니다. 포맷을 따로 설정해주지 않으면 Oracle DB는 해당 변수를 참조하여 날짜 포맷을 지정하게 됩니다.

이를 방지하는 방법은 간단합니다. 가급적 통일된 포맷을 사용하고, 통일해서 사용할 수 없다면 확실하게 합의하여 명시적으로 포맷을 변환하는 것입니다. 모든 환경의 설정값을 맞추는 방법도 가능하겠지만 공수도 많이 들어가고 바람직한 방법은 아닙니다.

<br>

#### Type-safe하게 Mapping/Schema 구성하기

제목이 너무 길어질 것 같아 생략했는데, **각종 언어와 Tool에서 쓰는 VO, DAO, Model, Interface 등등 모두 포함**한다 생각하시면 됩니다. 불가피한 경우가 아니라면 최대한 이런 규격을 맞출 수 있도록 하고, Type을 확실히 명시할 수 있도록 해야 합니다. 특히 Python이나 JS처럼 변수 타입 설정에 비교적 관대한 경우 관련 에러가 많이 발생할 수 있습니다. 사실 저도 JS를 개인적으로 사용할 때는 타입 고려하지 않고 쓸 때도 있습니다만... 되도록이면 실무에서는 JS는 Typescript를 대신 사용하거나, [prop-types][ref2] 등으로 안전장치를 두고 Python도 최대한 타입을 명시하려 노력 중입니다.

최근에 겪었던 상황은 Elasticsearch에서 대시보드를 만들 때였습니다. CPU 코어 값의 합을 구해야 하는데, 이 값은 `float` 값으로 들어옵니다. 그런데 첫 값은 정수라서 index 자동매핑이 `int`로 설정되었고 이로 인해 들어오는 숫자가 소수점이 모두 잘려 합이 맞지 않았던 문제가 있었습니다. 참고로, ES에는 [coerce][ref3]라는 옵션이 있어 정확히 type에 맞지 않아도 일단 값이 들어가도록 할 수 있습니다. 대신 연산 등에 사용되는 데이터는 해당 타입에 알맞게 변환이 됩니다. 이 기본값이 True였기 때문에 위와 같은 문제가 발생했었습니다.  
다행히도 해당 케이스는 데이터량이 많지 않아서 mapping을 새로 작성하고 데이터 재소급을 진행해 해결하긴 했습니다만, 규모가 컸다면 그만큼 대공사로 이어질 수도 있는 상황이었습니다.

<br>

#### 확실하게 분류하고 필터링하기

개발을 하다 보면 여러 데이터나 리소스를 분류하고 걸러야 할 때가 많습니다. 이 과정에서 label이나 기타 분류는 확실하게 대상을 대표할 수 있도록 하고, 필터링을 할 때는 정말 내가 원하는 케이스만 해당되도록 조건이 제대로 설정되었는지 체크해야 합니다.

이와 관련해서 최근 Kubernetes labeling 문제를 발견했던 적이 있었습니다. Service를 설정할 때 selector를 설정하는데, 필터링을 제대로 하지 않아 Terminate된 Pod까지 서비스에 포함되는 바람에 간헐적으로 네트워크 지연이 발생하는 현상이 있었고, 원인을 찾지 못한 채로 계속 사용을 하고 있었습니다. 해당 Pod는 실제 리소스가 뜨기 전 secret 정보를 설정하는 일종의 일회성 작업 Pod였는데 전임자가 구축할 당시에는 이런 Side Effect를 생각하지 못하고 label을 설정했던 것 같습니다. 이후에 label을 역할까지 명시하여 정확하게 변경하였고, 네트워크 순단 현상은 해결되었습니다. 기존에 이로 인해 단순 조회만으로도 5초 정도의 지연이 발생했었기 때문에 작지만 엄청난 개선사항이었습니다.

[ref1]: https://www.ibm.com/docs/ko/tap/3.5.2?topic=time-custom-date-formats
[ref2]: https://www.npmjs.com/package/prop-types
[ref3]: https://www.elastic.co/guide/en/elasticsearch/reference/current/coerce.html
